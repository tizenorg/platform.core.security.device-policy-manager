@startuml
namespace IPC {

class Socket {
-socketFd : int
+Socket(int)
+write(const void* buffer, const size_t size) const : void
+read(void *buffer, const size_t size) const : void
+accept() : Socket
+getFd() const : int
+{static} Socket create(const std::string& address)
+{static} Socket connect(const std::string& address)
}

class Message <DataType, Transmitter> {
-id : int
-type : int
+Message(const Message& message)
+createReplyMessage() const : Message
+createErrorMessage() const : Message
+enclose(const DataType& data) : void
+disclose(DataType& data) : void
+encode(const Transmitter& data) : void
+decode(Transmitter& data) : void
}

Message ..> Message : create for reply or error

class Connection <MainloopContext> {
-socket : Socket
+Connection(Socket&& sock)
+createMessage(...) : Message
+send(const Message& message) : void
+dispatch() const : Message
+attachMainloopContext(MainloopContext)
}

Connection "1" *--> "1" Socket
Connection ..> Message : create

class Mainloop {
-pollFd : int
+addEventSource(...) : void
+removeEventSource(const int fd) : void
+dispatch(const int timeout) : bool
+run(const int timeout = -1) : void
}

class Client <RequestType, ResponseType> {
-connection : std::shared_ptr<Connection>
-address : std::string
+Clent(const std::sting& address)
+connect() : void
+stop() : void
+methodCall(...) : ResponseType
}

Client "1" *-left-> "1" Connection

class Service {
-onNewConnection : CallbackDispatcher
-oncloseConnection : CallbackDispatcher
-methodRegistry : MethodRegistry
-connectionRegistry : ConnectionRegistry
-mainloop : Mainloop
-address : std::string
+Service(const std::string& address)
+start() : void
+stop() : void
setMethodhandler(...) : void
+setNewConnectionCallback(...) : void
+setCloseConnectionCallback(...) : void
}

Service -right-> "1..*" Connection
Service *--> "1" Mainloop

@enduml


